---
title: "Introduction to Deduplication and Weighted Deduplication by RecordLinkage"
output: html_document
---

```{r, message = FALSE}
library(RecordLinkage)
```

```{r}
data(RLdata500)
RLdata500[1:5, ]
```

### Comparison Pattern

A **Comparison Pattern** in record linkage is a way of showing how two records are compared to decide if they represent the same person or entity. Each record has multiple pieces of information, like name, address, or birth date, and a **comparison pattern** looks at each of these pieces to see how similar they are.

Question might rise while data investigation: Do the names match? Are the birth dates the same? The comparison result will answer those question. Each of these comparisons results in either a match (they are the same), or a mismatch (they are different).

#### Mini Example

For example, taking two persons' records from the RLdata500:

```{r}
example <- RLdata500[c(2, 43), ]
```

By just looking at the data, two records match among first name, and date of birth. By extracting comparison patterns of the example, the result will be:

```{r}
rpairs <- compare.dedup(RLdata500, identity = identity.RLdata500)
rpairs$pairs[rpairs$pairs$id1 == 2 & rpairs$pairs$id2 == 43, ]
```

Here by comparing id1=2 and id2 = 43, we can see couple of ones in the result. Those 1s indicate the matching of specific attributes. For example, the 1 in birth day `bd`, birth month `bm`, and birth year `by` indicate that two persons have the same birth dates. The last column `is_match` indicates if the two ids are the same person. In this case, id1=2 and id2=43 are the same person.

#### Comparison Functions

RecordLinkage contains two functions that could create comparison pattern of dataset:

1.  compare.dedup: To compare records within a single dataset to identify duplicates

    `compare.dedup (dataset, blockfld = FALSE, phonetic = FALSE,`

    `phonfun = soundex, strcmp = FALSE, strcmpfun = jarowinkler, exclude = FALSE,`

    `identity = NA, n_match = NA, n_non_match = NA)`

2.  compare.linkage: To compare records across two different datasets to find matches

    `compare.linkage (dataset1, dataset2, blockfld = FALSE,`

    `phonetic = FALSE, phonfun = soundex, strcmp = FALSE,`

    `strcmpfun = jarowinkler, exclude = FALSE, identity1 = NA, identity2 = NA,`

    `n_match = NA, n_non_match = NA)`

The key difference between these two functions is finding matches within a single dataset or across two different datasets.

```{r}
rpairs <- compare.dedup(RLdata500, identity = identity.RLdata500)
rpairs$pairs[1:5, ]
```

By calling `rpairs$pairs` , we could extract the comparison pattern resulted from `compare.dedup`

In above example, NA usually indicates the missing value in the dataset. id1 and id2 are two person that being compared; wherever there's a match, there will be a 1 indicating a match for specific column. For instance, person with id = 1 and person with id = 2 have a match on birth month `bm` . The final column `is_match` indicates if two persons are the same (1 for match, 0 for non-match)

There are more parameters we could tune to use above functions in different cases:

-   `blockfld`: Specifies the fields on which blocking should occur to limit the number of record comparisons (e.g., blocking on names)

-   `strcmp`: determines whether or not string comparison should be performed (such as `strcmp = TRUE` for names).

-   `phonetic`, `phonfun`: determines if a phonetic algorithm is used to compare strings (e.g. names) that sound alike but different in spelling; when `phonetic = TRUE`, phonetic algorithm applies to all columns, or giving specific column number to apply for chosen column. Specify phonetic algorithm to use using `phonfun`

-   `exclude`: specify if certain fields should be excluded from comparison

-   `identity`: store the true identity of records for validation

-   `n_match`, `n_non_match`: set manually the number of record pairs that are identified as matches or non-matches

More detailed usage of different parameters will be discussed in the later sections:

### Blocking

Blocking is a technique used in record linkage and deduplication to reduce the number of comparisons made between records. Every pair of records will be compared without blocking, which result in a long and expensive computation.

Thus, blocking helps by narrowing down the number of comparisons, where it constructs **blocking fields** that only compares records that share the same values for certain fields. There could be a single blocking field, or combining multiple fields, but only records that match in all specified fields will be compared.

Blocking could be easily implemented by utilizing `blockfld` parameter mentioned above:

1.  Single blocking field: only records with the same first name will be compared

```{r}
rpairs <- compare.dedup(RLdata500, blockfld = 1, identity = identity.RLdata500)
rpairs$pairs[1:5, ]
```

2.  Multiple blocking fields: Records with same birth dates will be compared.

```{r}
rpairs <- compare.dedup(RLdata500, blockfld = c(5:7), identity = identity.RLdata500)
rpairs$pairs[1:5, ]
```

3.  Combination: Records with same last name and same birth day and month will be compared.

```{r}
rpairs <- compare.dedup(RLdata500, blockfld = list(3, 6:7), identity = identity.RLdata500)
rpairs$pairs[c(1:9, 10:11), ]
```

### Phonetic Functions and String Comparison

Phonetic functions and string comparators are two methods used in record linkage to handle variations or errors in text data, like spelling mistakes or differences in pronunciation.

#### Phonetic Functions

**Phonetic functions** help match words that sound the same but might be spelled differently. For example, if someone's name is "Smith" but is misspelled as "Smyth," a phonetic function would convert both spellings into a code that represents how they sound. This way, the two names can still be matched, even though the spellings are different. Common phonetic algorithm that is used for English is **Soundex**.

By setting `phonetic` and specifying the phonetic algorithm to `phonfun`, phonetic algorithm will be applied while doing deduplication:

```{r}
rpairs<- compare.dedup(RLdata500, phonetic = 1, phonfun = soundex, blockfld = 1)
rpairs$pairs[1:5, ]
```

#### String Comparison

String comparators are another approach that measures how similar two strings are. Instead of converting the words into phonetic codes, string comparators compare the strings directly and give a similarity score between 0 and 1. A score of 0 means the strings are completely different, and a score of 1 means they are exactly the same. Commonly used string comparison functions are **jarowinkler** (Winkler (1990)) and edit distance-based **levenshteinSim**(Levenshtein).

String comparators will be applied by setting the `strcmp` argument to `TRUE` and specifying a comparison function using the `strcmpfun` argument:

```{r}
rpairs <- compare.dedup(RLdata500, strcmp = TRUE, strcmpfun = jarowinkler, blockfld = 1)
rpairs$pairs[1:5, ]
```

### Stochastic Record Linkage and Weight Calculation

**Stochastic record linkage** is a method that uses probabilities to decide whether two records belong to the same person or entity. It assumes that for each pair of records, there's a probability that they are either a match (the same) or a non-match (different). To make this decision, we calculate two probabilities:

1.  The chance that the records don't match.

2.  The chance that the records do match.

These probabilities are then used to calculate a **weight**, which helps to separate matches from non-matches. Moreover, it helps us decide whether the records are likely to represent the same person or not, based on how similar certain details (like names, addresses, etc.) are.

There are different ways to estimate the probabilities mentioned in the theory. In the **RecordLinkage** package, a method called the **EM algorithm** is used to make these estimates more accurate. The EM algorithm helps to automate this process by using a mathematical approach.

The **RecordLinkage** contains two weight calculation functions: `emWeights` (EM algorithm) and `epiWeights` (method by Contiero et al. (2005)):

1.  `emWeights(rpairs, cutoff = 0.95, verbose = TRUE)`
    -   `rpairs`: the record pairs we use to compute weight
    -   `cutoff`: Cutoff value for string comparator. Could be either value in [0,1] or a vector that has same length as the number of attributes in the dataset.
    -   `verbose`: Whether to print progress messages.
2.  `epiWeights(rpairs, e = 0.01, f, ...)`
    -   `e`: numeric vector representing error rate(s)
    -   `f`: numeric vector representing average frequency of attributes
    -   `withProgressBar`: Whether to display a progress bar

Example usage of the function could be something like the following:

```{r}
rpairs <- epiWeights(rpairs)
summary(rpairs)
```

By calling `summary()` , we could get a summary with matches, non-matches and the weights of the pairs in our dataset. Moreover, in **RecordLinkage** Package, there is a function called getPairs where we could get record pairs with customized min and max weights:

```{r}
head(getPairs(rpairs, 0.7, 0.5))
```

Here we are getting record pairs with weights between 0.5 and 0.7. What's more, we could use pairs with weights to perform classification. There are two corresponding classification methods to `emWeights` and `epiWeights`: emClassify and epiClassify. When the `threshold.upper` in the methods was set in parameters,the threshold of links is set and the threshold-based approach is used:

```{r}
result <- epiClassify(rpairs, 0.55)
summary(result)
```

Here threshold is set to 0.55. Calling summary on the record pairs show error measures and a table comparing true and predicted matching status. More classification methods will be stated in the following sections.
